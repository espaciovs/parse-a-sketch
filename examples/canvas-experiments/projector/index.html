<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Projector</title>
    <link rel="icon" href="../img/favicon.ico" type="image/x-icon" />
    <script src="/socket.io/socket.io.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #0051ff;
        font-family: Arial, sans-serif;
      }

      #canvas {
        position: absolute;
      }

      #menuBtn {
        position: fixed;
        bottom: 5px;
        left: 5px;
        padding: 5px 8px;
        background: #ffffff;
        color: rgb(0, 0, 0);
        border: none;
        cursor: pointer;
        z-index: 100;
        font-size: 11px;
        width: auto;
        border-radius: 3px;
      }

      #menuBtn:hover {
        background: #00ff0d;
      }

      #menu {
        position: fixed;
        left: -350px;
        bottom: 0;
        width: 330px;
        height: fit-content;
        max-height: 100vh;
        background: rgb(0.2, 0.2, 0.2, 0.5);
        color: white;
        padding: 20px;
        transition: left 0.3s;
        z-index: 99;
        overflow-y: auto;
      }

      #menu.visible {
        left: 0;
      }

      .control-group {
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid #444;
      }

      .control-group:last-child {
        border-bottom: none;
      }

      .control-group h3 {
        margin-bottom: 10px;
        font-size: 14px;
        color: #4caf50;
      }

      select,
      button {
        width: 100%;
        padding: 8px;
        margin-bottom: 10px;
        border: none;
        border-radius: 3px;
        cursor: pointer;
      }

      button {
        background: #555;
        color: white;
      }

      button:hover {
        background: #666;
      }

      .cruceta {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 5px;
        max-width: 150px;
        margin: 0 auto;
      }

      .cruceta button {
        height: 40px;
      }

      .cruceta .center {
        background: #4caf50;
      }

      #cornerIndicator {
        position: fixed;
        width: 20px;
        height: 20px;
        background: red;
        border: 2px solid white;
        border-radius: 50%;
        pointer-events: none;
        display: none;
        z-index: 98;
      }

      .info-text {
        font-size: 12px;
        color: #aaa;
        line-height: 1.4;
      }

      .status-badge {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 3px;
        font-size: 11px;
        margin-left: 5px;
      }

      .status-badge.on {
        background: #4caf50;
      }

      .status-badge.off {
        background: #f44336;
      }

      #toggleGrid {
        background: #4caf50;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div id="cornerIndicator"></div>

    <button id="menuBtn">‚öôÔ∏è</button>

    <div id="menu">
      <div class="control-group">
        <h3>üé® Modo de Visualizaci√≥n</h3>
        <button id="toggleGrid" onclick="toggleGridPattern()">
          üî≤ Mostrar Grid de Calibraci√≥n
        </button>

        <h3>üé® Color de Fondo</h3>
        <button id="toggleBackground" onclick="toggleBackground()">üîµ Cambiar a Negro</button>
      </div>

      <div class="control-group">
        <h3>üìê Configuraci√≥n de Deformaci√≥n</h3>
        <select id="configSelect">
          <option value="custom">Custom</option>
          <option value="pantalla1">Pantalla 1</option>
          <option value="pantalla2">Pantalla 2</option>
          <option value="centrado">Centrado</option>
        </select>
      </div>

      <div class="control-group">
        <h3>üìç Esquina: <span id="cornerName">Superior Izquierda</span></h3>
        <button id="changeCorner">Cambiar Esquina</button>
      </div>

      <div class="control-group">
        <button id="copyValues">üìã Copiar Valores</button>
      </div>

      <div class="control-group">
        <h3>üéÆ Mover Esquina</h3>
        <div class="cruceta">
          <div></div>
          <button data-dir="up">‚ñ≤</button>
          <div></div>
          <button data-dir="left">‚óÑ</button>
          <button class="center" id="resetCorner">Reset</button>
          <button data-dir="right">‚ñ∫</button>
          <div></div>
          <button data-dir="down">‚ñº</button>
          <div></div>
        </div>
      </div>

      <div class="control-group">
        <h3>
          üìä Estado de Visualizaci√≥n
          <span id="statusBadge" class="status-badge off">OFF</span>
        </h3>
        <div class="info-text" style="margin-top: 10px">
          <strong>Planta actual:</strong> <span id="plantaInfo">-</span><br />
          <strong>Pregunta:</strong> <span id="preguntaInfo">Todas</span><br />
          <strong>Filtro:</strong> <span id="filtroInfo">Todas</span><br />
          <strong>Opacidad:</strong> <span id="opacidadInfo">50%</span>
        </div>
      </div>

      <div class="control-group">
        <p class="info-text">
          Los controles de visualizaci√≥n se manejan desde el panel de Admin.
          Este men√∫ solo controla la deformaci√≥n del proyector.
        </p>
      </div>
    </div>

    <script>
      // ============================================
      // CONFIGURACI√ìN
      // ============================================
      const CONFIG = {
        IPhost: `http://192.168.1.129:5000`,
        colors: {
          red: "#ff548d",
          green: "#55ffad",
          point: "#fa7bb8",
          //COLORES REDRAW
          borrador: "#000000",
          pared: "#ffffff",
          asientos: "#0000ff",
          plantas: "#00ff00",
          iluminacion: "#ff0000",
          textil: "#ffff00",
          resto: "#00ffff",
          ventana: "#ff00ff",
        },
        canvas: {
          lineWidth: 6,
          pointRadius: 7,
          textFont: "18px Ubuntu, sans-serif",
        },
      };

      // ============================================
      // VARIABLES GLOBALES
      // ============================================
      var canvas = document.getElementById("canvas");
      var ctx = canvas.getContext("2d");
      var canvasSize = Math.min(
        window.innerHeight * 0.9,
        window.innerWidth * 0.9
      );

      canvas.width = canvasSize;
      canvas.height = canvasSize;

      // Estado del proyector
      const proyectorState = {
        plantaActual: null,
        mostrarRespuestas: false,
        opacidad: 0.5,
        filtroCorregido: "todos",
        preguntaSeleccionada: null, // null = todas, n√∫mero = pregunta espec√≠fica
        showGrid: false,
        fondoAzul: true, // false = negro, true = azul
      };

      // ============================================
      // FUNCI√ìN PARA DIBUJAR GRID DE CALIBRACI√ìN
      // ============================================

      function drawChessboard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        var squareSize = canvasSize / 7;
        for (var row = 0; row < 7; row++) {
          for (var col = 0; col < 7; col++) {
            ctx.fillStyle = (row + col) % 2 === 0 ? "black" : "black";
            ctx.fillRect(
              col * squareSize,
              row * squareSize,
              squareSize,
              squareSize
            );
          }
        }
      }

      function toggleGridPattern() {
        proyectorState.showGrid = !proyectorState.showGrid;
        const btn = document.getElementById("toggleGrid");

        if (proyectorState.showGrid) {
          btn.textContent = "üñºÔ∏è Mostrar Planta";
          btn.style.background = "#f44336";
          drawChessboard();
        } else {
          btn.textContent = "üî≤ Mostrar Grid de Calibraci√≥n";
          btn.style.background = "#4CAF50";
          actualizarInterfaz();
        }
      }

      function toggleBackground() {
        proyectorState.fondoAzul = !proyectorState.fondoAzul;

        if (proyectorState.fondoAzul) {
          document.body.style.background = "#0051ff";
          document.getElementById("toggleBackground").textContent =
            "üîµ Cambiar a Negro";
        } else {
          document.body.style.background = "#000000";
          document.getElementById("toggleBackground").textContent =
            "‚ö´ Cambiar a Azul";
        }
      }

      // ============================================
      // SOCKET.IO - COMUNICACI√ìN (VERSI√ìN CORREGIDA)
      // ============================================
      const socket = io();

      // Funci√≥n para debug de conexi√≥n
      socket.on("connect", () => {
        console.log("‚úÖ PROYECTOR - Conectado al servidor");
        console.log("‚úÖ PROYECTOR - ID del socket:", socket.id);

        // Solicitar estados iniciales
        socket.emit("solicitar-planta-actual");
        socket.emit("solicitar-estado-proyector");
      });

      // Debug para desconexi√≥n
      socket.on("disconnect", (reason) => {
        console.log("‚ùå PROYECTOR - Desconectado:", reason);
      });

      // Debug para errores
      socket.on("connect_error", (error) => {
        console.log("‚ùå PROYECTOR - Error de conexi√≥n:", error);
      });

      // ============================================
      // HANDLERS DE EVENTOS - TODOS LOS EVENTOS JUNTOS
      // ============================================

      // 1. Eventos de planta
      socket.on("planta-actual", (plantaObj) => {
        console.log("üåø PROYECTOR - Planta recibida:", plantaObj);
        proyectorState.plantaActual = plantaObj;
        if (!proyectorState.showGrid) {
          actualizarInterfaz();
        }
      });

      socket.on("imagen-cambiada", (plantaObj) => {
        console.log("üîÑ PROYECTOR - Cambio de planta:", plantaObj);
        proyectorState.plantaActual = plantaObj;
        if (!proyectorState.showGrid) {
          actualizarInterfaz();
        }
      });

      // 2. Eventos de estado del proyector (¬°ESTE ES EL IMPORTANTE!)
      socket.on("estado-proyector-actual", (estado) => {
        console.log("üéÆ PROYECTOR - Estado completo recibido:", estado);
        console.log(
          "üéÆ PROYECTOR - preguntaSeleccionada en estado:",
          estado.preguntaSeleccionada
        );

        // Actualizar TODO el estado, no solo partes
        proyectorState.mostrarRespuestas = estado.mostrarRespuestas;
        proyectorState.opacidad = estado.opacidad;
        proyectorState.filtroCorregido = estado.filtroCorregido;
        proyectorState.preguntaSeleccionada = estado.preguntaSeleccionada; // ‚Üê ¬°ESTA L√çNEA FALTABA!

        actualizarInfoPanel();
        if (!proyectorState.showGrid) {
          actualizarInterfaz();
        }
      });

      // 3. Eventos individuales de cambios (AGREGA ESTE QUE FALTABA)
      socket.on("proyector-pregunta-cambiado", (pregunta) => {
        console.log(
          "‚ùì PROYECTOR - EVENTO RECIBIDO: proyector-pregunta-cambiado",
          pregunta
        );
        console.log("‚ùì PROYECTOR - Tipo de pregunta:", typeof pregunta);

        proyectorState.preguntaSeleccionada = pregunta;

        console.log("‚ùì PROYECTOR - Estado actualizado:", proyectorState);

        actualizarInfoPanel();
        if (!proyectorState.showGrid) {
          actualizarInterfaz();
        }
      });

      // 4. Los otros eventos que ya ten√≠as (mantenerlos)
      socket.on("proyector-mostrar-respuestas-cambiado", (mostrar) => {
        console.log("üëÅÔ∏è PROYECTOR - Mostrar respuestas:", mostrar);
        proyectorState.mostrarRespuestas = mostrar;
        actualizarInfoPanel();
        if (!proyectorState.showGrid) {
          actualizarInterfaz();
        }
      });

      socket.on("proyector-opacidad-cambiada", (opacidad) => {
        console.log("üé® PROYECTOR - Opacidad:", opacidad);
        proyectorState.opacidad = opacidad;
        actualizarInfoPanel();
        if (!proyectorState.showGrid) {
          actualizarInterfaz();
        }
      });

      socket.on("proyector-filtro-corregido-cambiado", (filtro) => {
        console.log("üìä PROYECTOR - Filtro:", filtro);
        proyectorState.filtroCorregido = filtro;
        actualizarInfoPanel();
        if (!proyectorState.showGrid) {
          actualizarInterfaz();
        }
      });

      // ============================================
      // FUNCIONES DE VISUALIZACI√ìN
      // ============================================

      function actualizarInfoPanel() {
        const statusBadge = document.getElementById("statusBadge");
        statusBadge.textContent = proyectorState.mostrarRespuestas
          ? "ON"
          : "OFF";
        statusBadge.className = `status-badge ${
          proyectorState.mostrarRespuestas ? "on" : "off"
        }`;

        document.getElementById("plantaInfo").textContent =
          proyectorState.plantaActual
            ? proyectorState.plantaActual.titulo
            : "-";

        const filtroTexto = {
          todos: "Todas",
          sinCorregir: "Sin Corregir",
          corregido: "Corregidas",
        };
        document.getElementById("filtroInfo").textContent =
          filtroTexto[proyectorState.filtroCorregido];
        document.getElementById("opacidadInfo").textContent = `${Math.round(
          proyectorState.opacidad * 100
        )}%`;

        // MOSTRAR LA PREGUNTA SELECCIONADA
        const preguntaTexto =
          proyectorState.preguntaSeleccionada === null
            ? "Todas"
            : `Pregunta ${proyectorState.preguntaSeleccionada + 1}`;

        console.log(
          "üìù PROYECTOR - Actualizando panel - Pregunta:",
          preguntaTexto
        );

        // Si no existe el elemento, cr√©alo
        let preguntaElement = document.getElementById("preguntaInfo");
        if (!preguntaElement) {
          // Agregar al HTML si no existe
          const infoDiv = document.querySelector(".info-text");
          const preguntaLine = document.createElement("div");
          preguntaLine.innerHTML = `<strong>Pregunta:</strong> <span id="preguntaInfo">${preguntaTexto}</span>`;
          infoDiv.insertBefore(preguntaLine, infoDiv.firstChild.nextSibling);
          preguntaElement = document.getElementById("preguntaInfo");
        } else {
          preguntaElement.textContent = preguntaTexto;
        }
      }
      async function actualizarInterfaz() {
        if (!proyectorState.plantaActual) {
          dibujarMensajeEspera();
          return;
        }

        console.log(
          "Actualizando interfaz con planta:",
          proyectorState.plantaActual
        );

        // Cargar imagen de fondo
        await cargarImagenFondo(
          proyectorState.plantaActual.imagen.replace(".png", "p.png")
        );

        // Si debe mostrar respuestas, cargarlas
        if (proyectorState.mostrarRespuestas) {
          console.log("Cargando respuestas...");
          await cargarYDibujarRespuestas();
        }
      }

      function dibujarMensajeEspera() {
        ctx.fillStyle = "#0051ff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "white";
        ctx.font = "24px Arial";
        ctx.textAlign = "center";
        ctx.fillText(
          "Esperando planta desde Admin...",
          canvas.width / 2,
          canvas.height / 2
        );
      }

      async function cargarImagenFondo(url) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            console.log("Imagen cargada correctamente:", url);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            resolve();
          };
          img.onerror = (error) => {
            console.error("Error cargando imagen:", error);
            reject(error);
          };
          img.src =
            url.startsWith("http") || url.startsWith("/") ? url : `/${url}`;
        });
      }

      async function cargarYDibujarRespuestas() {
        if (!proyectorState.plantaActual) return;

        try {
          console.log(
            "Solicitando lista de archivos para planta:",
            proyectorState.plantaActual.id
          );

          // Obtener lista de archivos
          const response = await fetch(
            `${CONFIG.IPhost}/listar/${proyectorState.plantaActual.id}`
          );
          if (!response.ok) {
            console.log("Error al obtener lista de archivos");
            return;
          }

          const result = await response.json();
          console.log("Archivos disponibles:", result.datos);

          if (result.datos.length === 0) {
            console.log("No hay archivos disponibles");
            return;
          }

          // Filtrar archivos seg√∫n el filtro seleccionado
          let archivos = result.datos;

          console.log(
            "Pregunta seleccionada:",
            proyectorState.preguntaSeleccionada
          );

          // Filtrar por pregunta si est√° especificada
          if (proyectorState.preguntaSeleccionada !== null) {
            const preguntaNum = proyectorState.preguntaSeleccionada;
            console.log(`Filtrando por pregunta: ${preguntaNum}`);

            // Los archivos se guardan con formato: "preguntaIndex_userId" o "preguntaIndex_userId_corregido"
            archivos = archivos.filter((nombre) => {
              // Extraer el n√∫mero de pregunta del nombre del archivo
              // Formato esperado: "0_userId", "1_userId_corregido", etc.
              const partes = nombre.split("_");
              if (partes.length < 2) return false;

              const preguntaEnArchivo = parseInt(partes[0]);
              console.log(
                `Archivo: ${nombre}, Pregunta en archivo: ${preguntaEnArchivo}`
              );

              return preguntaEnArchivo === preguntaNum;
            });

            console.log(`Archivos de pregunta ${preguntaNum}:`, archivos);
          }

          // Filtrar por estado de correcci√≥n
          if (proyectorState.filtroCorregido === "sinCorregir") {
            archivos = archivos.filter(
              (nombre) => !nombre.includes("_corregido")
            );
            console.log("Archivos sin corregir:", archivos);
          } else if (proyectorState.filtroCorregido === "corregido") {
            archivos = archivos.filter((nombre) =>
              nombre.includes("_corregido")
            );
            console.log("Archivos corregidos:", archivos);
          }

          console.log(
            `Dibujando ${archivos.length} archivos con opacidad ${proyectorState.opacidad}`
          );

          // Cargar y dibujar cada archivo
          for (const archivo of archivos) {
            await cargarYDibujarArchivo(archivo);
          }
        } catch (error) {
          console.error("Error cargando respuestas:", error);
        }
      }

      async function cargarYDibujarArchivo(archivo) {
        try {
          const response = await fetch(
            `${CONFIG.IPhost}/cargar/datos/${proyectorState.plantaActual.id}/${archivo}`
          );
          if (!response.ok) {
            console.log("Error cargando archivo:", archivo);
            return;
          }

          const datos = await response.json();
          if (!datos.datos || datos.datos.length === 0) {
            console.log("Archivo sin datos:", archivo);
            return;
          }

          console.log(
            "Dibujando archivo:",
            archivo,
            "con",
            datos.datos.length,
            "segmentos"
          );

          // OBTENER DIMENSIONES ORIGINALES DEL CLIENTE
          const anchoOriginal = datos.ancho || canvasSize;
          const altoOriginal = datos.alto || canvasSize;

          // NUEVO: Obtener informaci√≥n del contenedor si est√° disponible
          const contenedorAncho = datos.contenedorAncho || anchoOriginal;
          const contenedorAlto = datos.contenedorAlto || altoOriginal;
          const backgroundSize = datos.backgroundSize || "contain";
          const backgroundPosition = datos.backgroundPosition || "center";

          console.log(
            `üìè Cliente - Canvas: ${anchoOriginal}x${altoOriginal}, Contenedor: ${contenedorAncho}x${contenedorAlto}`
          );
          console.log(
            `üìè Cliente - Background: ${backgroundSize}, ${backgroundPosition}`
          );

          // CALCULAR FACTORES DE ESCALA MEJORADOS
          let scaleX, scaleY;

          if (backgroundSize === "contain") {
            // Para 'contain', la imagen se escala manteniendo aspect ratio
            const scaleWidth = canvasSize / contenedorAncho;
            const scaleHeight = canvasSize / contenedorAlto;
            const scale = Math.min(scaleWidth, scaleHeight);

            scaleX = scale;
            scaleY = scale;

            console.log(`üìè Escalado 'contain': factor=${scale.toFixed(3)}`);
          } else if (backgroundSize === "cover") {
            // Para 'cover', la imagen cubre todo el contenedor
            const scaleWidth = canvasSize / contenedorAncho;
            const scaleHeight = canvasSize / contenedorAlto;
            const scale = Math.max(scaleWidth, scaleHeight);

            scaleX = scale;
            scaleY = scale;

            console.log(`üìè Escalado 'cover': factor=${scale.toFixed(3)}`);
          } else {
            // Para valores espec√≠ficos o 'auto'
            scaleX = canvasSize / anchoOriginal;
            scaleY = canvasSize / altoOriginal;
            console.log(
              `üìè Escalado directo: scaleX=${scaleX.toFixed(
                3
              )}, scaleY=${scaleY.toFixed(3)}`
            );
          }

          // Aplicar correcci√≥n de posici√≥n si es necesario
          let offsetX = 0;
          let offsetY = 0;

          if (backgroundSize === "contain") {
            // Calcular offset para centrar la imagen
            const scaledWidth = contenedorAncho * scaleX;
            const scaledHeight = contenedorAlto * scaleY;

            offsetX = (canvasSize - scaledWidth) / 2;
            offsetY = (canvasSize - scaledHeight) / 2;

            console.log(
              `üìè Offset de centrado: X=${offsetX.toFixed(
                1
              )}, Y=${offsetY.toFixed(1)}`
            );
          }

          // Dibujar cada conjunto de datos CON ESCALADO MEJORADO
          datos.datos.forEach((dataArray) => {
            if (dataArray.length > 0 && typeof dataArray[0] === "string") {
              const dataString = dataArray.join(",");
              const parsedData = parseDataString(dataString);
              drawFromData(parsedData, scaleX, scaleY, offsetX, offsetY);
            }
          });
        } catch (error) {
          console.error("Error cargando archivo:", archivo, error);
        }
      }
      // ============================================
      // PARSEO Y DIBUJADO DE DATOS
      // ============================================

      function parseDataString(dataString) {
        const drawingSegments = dataString.split("|");

        return {
          segments: drawingSegments.map((segment) => {
            const parts = segment.split(",");
            const type = parts[0];

            if (type === "Text") {
              return {
                type: parts[0],
                color: parts[1],
                points: [
                  parts[2],
                  parseFloat(parts[3]),
                  parseFloat(parts[4]),
                  parts[5] || null,
                ],
              };
            } else {
              return {
                type: parts[0],
                color: parts[1],
                points: parts.slice(2).map((coord) => parseFloat(coord)),
              };
            }
          }),
        };
      }

      function drawFromData(
        parsedData,
        scaleX = 1,
        scaleY = 1,
        offsetX = 0,
        offsetY = 0
      ) {
        const { segments } = parsedData;

        ctx.save();
        ctx.globalAlpha = proyectorState.opacidad;

        segments.forEach((segment) => {
          switch (segment.type) {
            case "Draw":
              drawSegment(segment, scaleX, scaleY, offsetX, offsetY);
              break;
            case "Point":
              drawPoint(segment, scaleX, scaleY, offsetX, offsetY);
              break;
            case "Text":
              drawText(segment, scaleX, scaleY, offsetX, offsetY);
              break;
          }
        });

        ctx.restore();
      }

      function drawSegment(
        segment,
        scaleX = 1,
        scaleY = 1,
        offsetX = 0,
        offsetY = 0
      ) {
        const points = segment.points;
        if (points.length < 2) return;

        const colorToUse = CONFIG.colors[segment.color] || "#000";

        ctx.strokeStyle = colorToUse;
        ctx.lineWidth = CONFIG.canvas.lineWidth;
        ctx.lineCap = "round";

        ctx.beginPath();
        ctx.moveTo(points[0] * scaleX + offsetX, points[1] * scaleY + offsetY);

        for (let i = 2; i < points.length; i += 2) {
          if (i + 1 < points.length) {
            ctx.lineTo(
              points[i] * scaleX + offsetX,
              points[i + 1] * scaleY + offsetY
            );
          }
        }

        ctx.stroke();
      }

      function drawPoint(
        segment,
        scaleX = 1,
        scaleY = 1,
        offsetX = 0,
        offsetY = 0
      ) {
        const points = segment.points;
        if (points.length < 2) return;

        ctx.beginPath();
        ctx.arc(
          points[0] * scaleX + offsetX,
          points[1] * scaleY + offsetY,
          CONFIG.canvas.pointRadius,
          0,
          2 * Math.PI
        );
        ctx.fillStyle = CONFIG.colors.point;
        ctx.fill();
      }

      function drawText(
        segment,
        scaleX = 1,
        scaleY = 1,
        offsetX = 0,
        offsetY = 0
      ) {
        if (segment.points.length < 3) return;

        const text = segment.points[0];
        const x = parseFloat(segment.points[1]) * scaleX + offsetX;
        const y = parseFloat(segment.points[2]) * scaleY + offsetY;
        const color = segment.color;

        // Usar la misma font que en la aplicaci√≥n principal
        const font = segment.points[5] || CONFIG.canvas.textFont; // El font est√° en la posici√≥n 5 si se guard√≥

        ctx.save();
        ctx.font = font; // ‚Üê USAR EL FONT GUARDADO
        ctx.fillStyle = CONFIG.colors[color] || CONFIG.colors.green;
        ctx.textAlign = "left"; // ‚Üê FORZAR ALINEACI√ìN IZQUIERDA
        ctx.textBaseline = "alphabetic"; // ‚Üê FORZAR BASELINE CONSISTENTE
        ctx.fillText(text, x, y);
        ctx.restore();
      }
      // ============================================
      // INICIALIZACI√ìN
      // ============================================

      window.addEventListener("load", () => {
        // Iniciar con grid de calibraci√≥n
        drawChessboard();
        actualizarInfoPanel();
      });
    </script>

    <!-- L√≥gica de deformaci√≥n (tu c√≥digo existente) -->
    <script src="tablero-deformable.js"></script>
  </body>
</html>
